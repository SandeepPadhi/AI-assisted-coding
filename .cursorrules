# .cursorrules — MVP-First LLD Interview Guide

> Purpose: Interview-optimized guide for AI-assisted LLD rounds. Emphasizes **minimal viable product** with **surgical changes** to avoid cascading modifications across the codebase.

---

## Core Philosophy: MVP-First with Surgical Precision

**Primary Goals:**
1. **Identify top 3-4 core features** that define the system's essence
2. **Make minimal, isolated changes** that don't ripple across the entire codebase
3. **Demonstrate architecture thinking** without over-engineering
4. **Show incremental development** skills

---

## MANDATORY: Feature Prioritization Framework

Before any coding, **always** identify and agree on:

### Step 0: Feature Triage (30 seconds max)
```
Core Features (Must Have - MVP):
1. [Primary entity creation/management]
2. [Core business operation #1]
3. [Core business operation #2]
4. [Basic query/retrieval]

Nice-to-Have (Post-MVP):
- Advanced search/filtering
- Complex business rules
- Performance optimizations
- Advanced error handling
```

**Example for Library System:**
- Core: Create users, add books, borrow books, return books
- Post-MVP: Late fees, reservations, search filters, admin dashboard

---

## The 4-Part Workflow (Mandatory)

### Part 1: MVP Core (≤200 lines, 15-20 minutes)
**Deliverables:**
- 2-3 core entities with basic attributes only
- 1 in-memory repository per entity (save, get_by_id, list_all only)
- 1 manager with 2-3 core operations
- Simple orchestrator with demo showing happy path
- README with 5-line usage example

**MVP Rules:**
- No validations beyond null checks
- No error handling beyond basic exceptions
- No external services
- No complex business rules

### Part 2: Add ONE Strategic Feature (≤100 lines, 10 minutes)
**Choose exactly ONE:**
- Add one new entity with relationships
- Add one business rule/validation
- Add one external service mock
- Add one query filter/search

**Constraint:** Changes should touch ≤3 existing files

### Part 3: Harden Core Paths (≤150 lines, 10 minutes)
**Focus ONLY on MVP features:**
- Add input validation for core operations
- Add 3-5 custom exceptions
- Add error handling for happy path scenarios
- Add docstrings to public methods

### Part 4: Minimal Testing (≤100 lines, 10 minutes)
- 3-5 unit tests covering core happy paths
- 1-2 error case tests
- README with examples and trade-offs

---

## Layering Rules (Simplified for MVP)

### 1. Entities (Data + Basic Invariants Only)
```python
class User:
    # id: unique identifier for user lookup
    # name: display name for user interface
    # is_active: prevents operations when False (business rule)
    def __init__(self, id: str, name: str, is_active: bool = True):
        if not id or not name:  # Only basic null checks in MVP
            raise ValueError("ID and name required")
        self.id = id
        self.name = name
        self.is_active = is_active
```

### 2. Repositories (Minimal Interface with Specific Names)
```python
# MVP Repository Interface (only 4 methods max with targeted names)
class BaseRepository(ABC):
    @abstractmethod
    def save_entity_to_storage(self, entity) -> None: pass
    
    @abstractmethod
    def find_entity_by_unique_id(self, id: str): pass
    
    @abstractmethod
    def retrieve_all_entities_from_storage(self) -> List: pass
    
    @abstractmethod
    def remove_entity_by_id(self, id: str) -> bool: pass
```

### 3. Managers (2-3 Core Operations Max)
- Focus on top 3 business operations only
- No complex business logic in MVP
- Return simple success/failure indicators

### 4. Orchestrator (Demo Only)
- Wire 2-3 managers
- Show 1 complete user journey
- Print results for manual verification

---

## Surgical Change Principles

### 1. Isolation Rules
- **New features = New files** when possible
- **Modify existing files** only for direct dependencies
- **Avoid touching more than 3 files** per iteration

### 2. Change Impact Analysis (say this aloud)
Before each change, state:
```
"This change will:
- Add [X] new files
- Modify [Y] existing files: [list them]
- Impact [Z] other components: [list them]
- Estimated lines: [number]"
```

### 3. Extension Points (Design for Future)
Always mention but don't implement:
```python
# Extension points for post-MVP:
# - Repository.find_by_criteria() for advanced search
# - Manager.validate_business_rules() for complex rules
# - External services integration layer
```

---

## MVP Code Patterns

### Pattern 1: Minimal Entity Design
```python
# MVP: Basic attributes only
class Book:
    def __init__(self, id: str, title: str, available: bool = True):
        self.id = id
        self.title = title
        self.available = available

# Post-MVP: Rich domain model
# - ISBN, author, category, publication_date
# - Business rules, validation methods
```

### Pattern 2: Staged Repository Evolution
```python
# Part 1: Basic CRUD (specific action names)
class InMemoryBookRepository:
    def save_book_to_catalog(self, book): pass
    def find_book_by_id(self, book_id): pass
    def get_all_books_in_catalog(self): pass

# Part 2: Add ONE specific query method
def find_all_available_books_for_borrowing(self): pass

# Part 3: Add error handling
# Part 4: Add interface compliance tests
```

### Pattern 3: Manager Growth Strategy
```python
# Part 1: Happy path only (ultra-specific names)
def attempt_book_borrowing_for_user(self, user_id: str, book_id: str) -> bool:
    user = self.user_repo.find_user_by_id(user_id)
    book = self.book_repo.find_book_by_id(book_id)
    # Simple assignment
    return True

def process_book_return_from_user(self, user_id: str, book_id: str) -> bool:
    # Mark book as available
    return True

# Part 2: Add ONE business rule
def attempt_book_borrowing_with_availability_check(self, user_id: str, book_id: str) -> bool:
    # Add availability verification
    
# Part 3: Add error handling and validation
# Part 4: Add detailed return status
```

---

## Interview Communication Framework

### Opening (30 seconds)
"I'll use a 4-part MVP approach with explicit design patterns:
1. **Core MVP** with 3-4 essential features using Repository and Service Layer patterns
2. **Add one strategic feature** using appropriate design pattern (Strategy/Factory/etc.)
3. **Harden the core paths** with validation patterns
4. **Add basic tests** with Test Fixture patterns

Each part ≤200 lines with surgical changes and documented patterns. Sound good?"

### During Implementation
- **Narrate assumptions**: "I'm assuming X for MVP, we can extend later"
- **State change scope**: "This touches 2 files, adds 1 new class"
- **Highlight extension points**: "Here's where we'd add [advanced feature] post-MVP"
- **Declare design patterns**: "I'm using Repository Pattern here for data abstraction, and Service Layer Pattern for business logic"
- **Justify pattern choices**: "Repository gives us testability but adds abstraction - good trade-off for this system"

### After Each Part
"Here's what we accomplished and potential next steps:

**Analysis & Improvements:**
- **Extensibility**: Easy to add [X], harder to add [Y]
- **Missing**: [Validation/Error handling/Performance]
- **Trade-offs**: [Simplicity vs Features]

Should we add more complexity or move to the next part?"

---

## Anti-Patterns to Avoid (Common LLM Mistakes)

❌ **Over-implementing**: Don't build what wasn't asked for
❌ **Premature abstraction**: No interfaces until Part 3
❌ **Cascade changes**: Don't modify 10 files for 1 feature
❌ **Perfect code syndrome**: MVP should be "good enough"
❌ **All-at-once implementation**: Always deliver incrementally

✅ **Do instead**: Implement minimum, show it works, ask for next step

---

## Quick Reference: MVP Decision Tree

```
New requirement comes up:
├─ Is it one of the top 3-4 core features?
│  ├─ Yes → Implement minimally in current part
│  └─ No → Add to "Post-MVP" list, mention as extension point
└─ Does it require changing >3 files?
   ├─ Yes → Break into smaller sub-features
   └─ No → Proceed with surgical implementation
```

---

## File Templates for Quick Start

### Template: Entity with MVP Comments
```python
# Design Pattern: Value Object / Entity
# Purpose: Represent core business concept with basic invariants
# Implementation: Data class with constructor validation
# Trade-offs: Simplicity vs rich domain methods
class EntityName:
    # param1: why this exists and what constraint
    # param2: business purpose and validation rule
    def __init__(self, param1: Type, param2: Type):
        # Basic null/empty checks only in MVP
        self.param1 = param1
        self.param2 = param2
        
    # Extension point: add validation_method() post-MVP (Strategy Pattern)
```

### Template: Manager with MVP Operations
```python
# Design Pattern: Application Service / Service Layer
# Purpose: Coordinate business workflows across multiple repositories
# Implementation: Stateless service with dependency injection
# Trade-offs: Clear separation of concerns vs potential over-abstraction
class EntityManager:
    def __init__(self, entity_repo: BaseRepository):
        self._entity_repo = entity_repo
    
    def register_new_entity_in_system(self, **kwargs) -> str:
        # Happy path implementation only
        # Pattern: Template Method (structure defined, details filled)
        pass
    
    def retrieve_entity_with_business_rules(self, id: str):
        # Basic retrieval with domain logic
        # Pattern: Specification Pattern (extension point for complex queries)
        pass
    
    # Extension point: add complex_business_workflow() post-MVP (Command Pattern)
```

---

## Success Metrics for Interview

✅ **Part 1 Complete**: Working demo in ≤20 minutes
✅ **Clean Architecture**: Clear separation of concerns
✅ **Incremental Delivery**: Each part builds naturally on previous
✅ **Extension Awareness**: Can explain what comes next
✅ **Change Control**: Never modify >300 lines per iteration

---

## Emergency Shortcuts (if time pressure)

If running behind schedule:
1. **Skip Part 4** (tests) and focus on working demo
2. **Combine Parts 2+3** into "Add feature + basic error handling"
3. **Hardcode configuration** instead of building config systems
4. **Use print statements** instead of proper logging
5. **Document shortcuts** in README as "Production TODOs"

---

## Pre-Interview Mental Checklist

Before starting any LLD interview:
- [ ] Understand the top 3-4 core features
- [ ] Plan the 4-part approach
- [ ] Know which files you'll create in Part 1
- [ ] Identify 2-3 potential "Part 2" features
- [ ] Practice saying the change impact analysis

**Remember**: MVP is about proving you can architect and deliver incrementally, not about building production-ready software.

---

*Good luck with your Cred interview! Focus on demonstrating systematic thinking and controlled development over flashy features.*